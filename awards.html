<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Rocco Oliveto's Webpage</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        
        <meta name="description" content="Personal web page by Rocco Oliveto" />
        <meta name="keywords" content="Rocco, Oliveto, Home page, Software engineering, Software maintenance, Software evolution, Traceability, Empirical Software Engineering, Search-based software engineering" />

        <link rel="shortcut icon" href="../favicon.ico">

        <!--CSS styles-->
        <link rel="stylesheet" href="css/bootstrap.css">
        <link rel="stylesheet" href="css/font-awesome.min.css">  
        <link rel="stylesheet" href="css/perfect-scrollbar-0.4.5.min.css">
        <link rel="stylesheet" href="css/magnific-popup.css">
        <link rel="stylesheet" href="css/style.css">
        <link id="theme-style" rel="stylesheet" href="css/styles/default.css">

        
        <!--/CSS styles-->
        <!--Javascript files-->
        <script type="text/javascript" src="js/jquery-1.10.2.js"></script>
        <script type="text/javascript" src="js/TweenMax.min.js"></script>
        <script type="text/javascript" src="js/jquery.touchSwipe.min.js"></script>
        <script type="text/javascript" src="js/jquery.carouFredSel-6.2.1-packed.js"></script>
        
        <script type="text/javascript" src="js/modernizr.custom.63321.js"></script>
        <script type="text/javascript" src="js/jquery.dropdownit.js"></script>

        <script type="text/javascript" src="js/jquery.stellar.min.js"></script>
        <script type="text/javascript" src="js/ScrollToPlugin.min.js"></script>

        <script type="text/javascript" src="js/bootstrap.min.js"></script>

        <script type="text/javascript" src="js/jquery.mixitup.min.js"></script>

        <script type="text/javascript" src="js/masonry.min.js"></script>

        <script type="text/javascript" src="js/perfect-scrollbar-0.4.5.with-mousewheel.min.js"></script>

        <script type="text/javascript" src="js/magnific-popup.js"></script>
        <script type="text/javascript" src="js/custom.js"></script>

        <!--/Javascript files-->

    </head>
    <body>
        <div id="wrapper">
            <a href="#sidebar" class="mobilemenu"><i class="icon-reorder"></i></a>

            <div id="sidebar">
                <div id="main-nav">
                    <div id="nav-container">
                        <div id="profile" class="clearfix">
                            <div class="portrate hidden-xs"></div>
                            <div class="title">
                                <h2>Rocco Oliveto</h2>
                                <h3>University of Molise</h3>
                            </div>
                            
                        </div>
                        <ul id="navigation">
                            <li>
                                <a href="index.html">
                                    <div class="icon icon-user"></div>
                                    <div class="text">Home</div>
                                </a>
                            </li>  

                            <li>
                                <a href="publication.html">
                                    <div class="icon icon-edit"></div>
                                    <div class="text">Publications</div>
                                </a>
                            </li> 

                            <li class="currentmenu">
                                <a href="awards.html">
                                    <div class="icon icon-star"></div>
                                    <div class="text">Awards</div>
                                </a>
                            </li> 

                            <li>
                                <a href="teaching.html">
                                    <div class="icon icon-time"></div>
                                    <div class="text">Teaching</div>
                                </a>
                            </li>
                        </ul>
                        <div>
                            <p style="text-align: center; color: white;">
                                <br><br>
                                My ORC<span style="color: green">ID</span> - <a href="http://orcid.org/0000-0002-7995-8582" target="BLANK">Link</a><br>
                            <img src="img/qrcode.png" style="width: 50%">
                            </p>
                        </div>
                    </div>        
                </div>
                
                <div class="social-icons">
                    <ul>
                        <li><a href="https://www.facebook.com/rocco.oliveto.1" target="_BLANK"><i class="icon-facebook"></i></a></li>
                        <li><a href="https://twitter.com/roccooliveto" target="_BLANK"><i class="icon-twitter"></i></a></li>
                        <li><a href="https://it.linkedin.com/pub/rocco-oliveto/54/5b/114" target="_BLANK"><i class="icon-linkedin"></i></a></li>
                    </ul>
                </div>    
            </div>

            <div id="main">
            
                <div id="teaching" class="page">
                    <div class="pageheader">
                        <div class="headercontent">
                            <div class="section-container">
                                
                                <h2 class="title">Awards</h2>
                                
                                <div class="row">
                                    <div class="col-md-12">
                                        <p style="text-align:right;">
                                        	<em>You're not obligated to win. You're obligated to keep trying. To the best you can do everyday.<br>(Jason Mraz)</em>.
                                        </p>
                                        <p>
                                            As for the publications, these awards represent the results of several fruitful collaborations
                                            	with excellent students and great colleagues around the world. Once again, without their support I would not
                                                have ever been able to get all the awards listed below. Thanks to all!
                                    	</p>                                    
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="pagecontents">
                        <div class="section color-1">
                            <div class="section-container">
                                <div class="row">
                                    <div class="col-md-10 col-md-offset-1">
                                        <div class="title text-center">
                                            <h3>Recognitions based on bibliometric indexes</h3>
                                        </div>
                                        <ul class="ul-dates">
                                            <li>
                                                <div class="dates">
                                                    <span>2021</span>
                                                    <span>2014</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Top Scientists in the Computer Science Area: 15th place in Italy and 1051st place in the world</h4>
                                                    <p>In 2022 I was ranked at the 15th in Italy and at the 1051st in the world in the eighth edition of the ranking of top scientists in the computer science area. The ranking was published by Research.com, a leading website for computer science research that has been offering credible data on scientific contributions since 2014.</p>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>2020</span>
                                                    <span>2013</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Top Scientists in the Software Engineering Area: 4th place in the world</h4>
                                                    <p>In 2021 I was ranked at the 4th place in a bibliometric study conducted, over an eight-year period (2013-2020), with the aim of identifying, worldwide, the most active researchers in the field of software engineering (<a href="https://www.sciencedirect.com/science/article/pii/S0164121221001266?casa_token=ZZz656T2z0wAAAAA:ONwaTaleozf5Qg-w1lkW2Tl-epE71rk7T8YnqcMNUGpY1Ru7pZ9UIlK9pJilGlxLK7zXMmYBGg">details</a>)</p>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>2017</span>
                                                    <span>2010</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Top Scientists in the Software Engineering Area (Consoloditar category): 2nd place in the world</h4>
                                                    <p>In 2018, I was ranked at the 2nd place in the word, in the consolidator category, in a bibliometric study conducted, over an eight-year period (2010-2017), with the aim of identifying, worldwide, the top 20 early stage, consolidator and experienced researchers in the field of software engineering (<a href="https://www.sciencedirect.com/science/article/pii/S0164121218302334?casa_token=6Hl1I18yes4AAAAA:Cddf_p74jDZihZnobTDnobZC9otA3ofepo9jVCd9kU3ewTHTAVYk2uvXDwPpdPd0jQJd3H-poQ">details</a>)</p>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="section color-2">
                            <div class="section-container">
                                <div class="row">
                                    <div class="col-md-10 col-md-offset-1">
                                        <div class="title text-center">
                                            <h3>Most Influential Paper (MIP) Awards</h3>
                                        </div>
                                        <ul class="ul-dates-gray">
                                            <li>
                                                <div class="dates">
                                                    <span>SCAM</span>
                                                    <span>2022</span>
                                                </div>
                                                <div class="content">
                                                    <h4>When does a Refactoring Induce Bugs? An Empirical Study<br>
                                                        by <em>G. Bavota, B. De Carluccio, A. De Lucia, M. Di Penta, R. Oliveto, O. Strollo</em>
                                                        <h5>22nd IEEE International Working Conference on Source Code Analysis and Manipulation</h5></h4>
                                                    <p>Refactorings are - as defined by Fowler - behavior preserving source code transformations. Their main purpose is to improve maintainability or comprehensibility, or also reduce the code footprint if needed. In principle, refactorings are defined as simple operations so that are "unlikely to go wrong" and introduce faults. In practice, refactoring activities could have their risks, as other changes. This paper reports an empirical study carried out on three Java software systems, namely Apache Ant, Xerces, and Ar-go UML, aimed at investigating to what extent refactoring activities induce faults. Specifically, we automatically detect (and then manually validate) 15,008 refactoring operations (of 52 different kinds) using an existing tool (Ref-Finder). Then, we use the SZZ algorithm to determine whether it is likely that refactorings induced a fault. Results indicate that, while some kinds of refactorings are unlikely to be harmful, others, such as refactorings involving hierarchies (e.g., pull up method), tend to induce faults very frequently. This suggests more accurate code inspection or testing activities when such specific refactorings are performed.</p>

                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ICSME</span>
                                                    <span>2021</span>
                                                </div>
                                                <div class="content">
                                                    <h4>On integrating orthogonal information retrieval methods to improve traceability recovery <br>
                                                        by <em>M. Gethers, R. Oliveto, D. Poshyvanyk, A. De Lucia </em>
                                                        <h5>37th IEEE International Conference on Software Maintenance and Evolution</h5></h4>
                                                    <p>Different Information Retrieval (IR) methods have been proposed to recover traceability links among software artifacts. Until now there is no single method that sensibly outperforms the others, however, it has been empirically shown that some methods recover different, yet complementary traceability links. In this paper, we exploit this empirical finding and propose an integrated approach to combine orthogonal IR techniques, which have been statistically shown to produce dissimilar results. Our approach combines the following IR-based methods: Vector Space Model (VSM), probabilistic Jensen and Shannon (JS) model, and Relational Topic Modeling (RTM), which has not been used in the context of traceability link recovery before. The empirical case study conducted on six software systems indicates that the integrated method outperforms stand-alone IR methods as well as any other combination of non-orthogonal methods with a statistically significant margin.</p>

                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ICPC</span>
                                                    <span>2020</span>
                                                </div>
                                                <div class="content">
                                                    <h4>On the Equivalence of Information Retrieval Methods for Automated Traceability Link Recovery <br>
                                                        by <em>R. Oliveto, M. Gethers, D. Poshyvanyk, A. De Lucia</em>
                                                        <h5>28th International Conference on Program Comprehension</h5></h4>
                                                    <p>We present an empirical study to statistically analyze the equivalence of several traceability recovery methods based on Information Retrieval (IR) techniques. The analysis is based on Principal Component Analysis and on the analysis of the overlap of the set of candidate links provided by each method. The studied techniques are the Jensen-Shannon (JS) method, Vector Space Model (VSM), Latent Semantic Indexing (LSI), and Latent Dirichlet Allocation (LDA). The results show that while JS, VSM, and LSI are almost equivalent, LDA is able to capture a dimension unique to the set of techniques which we considered.</p>

                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>

                            </div>
                        </div>
                        <div class="section color-1">
                            <div class="section-container">
                                <div class="row">
                                    <div class="col-md-10 col-md-offset-1">
                                        <div class="title text-center">
                                            <h3>ACM Sigsoft Distinguished Paper Awards</h3>
                                        </div>
                                        <ul class="ul-dates">
                                            <li>
                                                <div class="dates">
                                                    <span>MSR</span>
                                                    <span>2019</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Data-driven solutions to detect API compatibility issues in Android: an empirical study<br>
                                                        by <em>S. Scalabrino, G. Bavota, M. Linares-Vásquez, M. Lanza, R. Oliveto</em>
                                                        <br><h5>16th International Conference on Mining Software Repositories</h5></h4>
                                                    <p>Android apps are inextricably linked to the official Android APIs. Such a strong form of dependency implies that changes introduced in new versions of the Android APIs can severely impact the apps' code, for example because of deprecated or removed APIs. In reaction to those changes, mobile app developers are expected to adapt their code and avoid compatibility issues. To support developers, approaches have been proposed to automatically identify API compatibility issues in Android apps. The state-of-the-art approach, named CiD, is a data-driven solution learning how to detect those issues by analyzing the changes in the history of Android APIs ("API side" learning). While it can successfully identify compatibility issues, it cannot recommend coding solutions. We devised an alternative data-driven approach, named ACRYL. ACRYL learns from changes implemented in other apps in response to API changes ("client side" learning). This allows not only to detect compatibility issues, but also to suggest a fix. When empirically comparing the two tools, we found that there is no clear winner, since the two approaches are highly complementary, in that they identify almost disjointed sets of API compatibility issues. Our results point to the future possibility of combining the two approaches, trying to learn detection/fixing rules on both the API and the client side. </p>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ASE</span>
                                                    <span>2017</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Automatically Assessing Code Understandability: How Far Are We?<br>
                                                    by <em>S. Scalabrino, G. Bavota, C. Vendome, M. Linares-Vasquez, D. Poshyvanyk, R. Oliveto</em>
                                                    <br><h5>32nd IEEE/ACM International Conference on Automated Software Engineering</h5></h4>
                                                    <p>Program understanding plays a pivotal role in software maintenance and evolution: a deep understanding of code is the stepping stone for most software-related activities, such as bug fixing or testing. Being able to measure the understandability of a piece of code might help in estimating the effort required for a maintenance activity, in comparing the quality of alternative implementations, or even in predicting bugs. Unfortunately, there are no existing metrics specifically designed to assess the understandability of a given code snippet. In this paper we perform a first step in this direction, by studying the extent to which several types of metrics computed on code, documentation and developers correlate with code understandability. To perform such an investigation we ran a study with 46 participants who were asked to understand eight code snippets each. We collected a total of 324 evaluations aiming at assessing the perceived understandability, the actual level of understanding and the time needed to understand a code snippet. Our results demonstrate that none of the (existing and new) metrics we considered is able to capture code understandability, not even the ones assumed to assess quality attributes strongly related with it, such as code readability and complexity. </p>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ICPC</span>
                                                    <span>2016</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Improving Code Readability Models with Textual Features<br>
                                                    by <em>S. Scalabrino, M. Linares-Vasquez, D. Poshyvanyk, R. Oliveto</em>
                                                    <br><h5>24th International Conference on Program Comprehension</h5></h4>
                                                    <p>Code reading is one of the most frequent activities in software maintenance; before implementing changes, it is necessary to fully understand source code often written by other developers. Thus, readability is a crucial aspect of source code that might significantly influence program comprehension effort. In general, models used to estimate software readability take into account only structural aspects of source code, e.g., line length and a number of comments. However, code is a particular form of text; therefore, a code readability model should not ignore the textual aspects of source code encapsulated in identifiers and comments. In this paper, we propose a set of textual features that could be used to measure code readability. We evaluated the proposed textual features on 600 code snippets manually evaluated (in terms of readability) by 5K+ people. The results show that the proposed features complement classic structural features when predicting readability judgments. Consequently, a code readability model based on a richer set of features, including the ones proposed in this paper, achieves a significantly better accuracy as compared to all the state-of-the-art readability models.
                                                    </p>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ICSE</span>
                                                    <span>2015</span>
                                                </div>
                                                <div class="content">
                                                    <h4>When and Why Your Code Starts to Smell Bad<br>
                                                            by <em>M. Tufano, F. Palomba, G. Bavota, R. Oliveto, M. Di Penta, A. De Lucia, and D. Poshyvanyk</em>
                                                    <br><h5>37th International Conference on Software Engineering</h5></h4>
                                                    
                                                    <p>In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e. symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, we conducted a large empirical study over the change history of 200 open source projects from different software ecosystems and investigated when bad smells are introduced by developers, and the circumstances and reasons behind their introduction. Our study required the development of a strategy to identify smell-introducing commits, the mining of over 0.5M commits, and the manual analysis of 9,164 of them (i.e. those identified as smell-introducing). Our findings mostly contradict common wisdom stating that smells are being introduced during evolutionary tasks. In the light of our results, we also call for the need to develop a new generation of recommendation systems aimed at properly planning smell refactoring activities.</p>
                                                        
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ESEC<br>FSE</span>
                                                    <span>2015</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Optimizing Energy Consumption of GUIs in Android Apps: A Multi-objective Approach
                                                    by <em>M. Linares-Vasquez, G. Bavota, C. Bernal-Cardenas, R. Oliveto, M. Di Penta, D. Poshyvanyk</em>
                                                    <h5>10th Joint Meeting of the European Software Engineering Conference and the 23rd ACM SIGSOFT Symposium on the Foundations of Software Engineering</h5></h4>
                                                    <p>The wide diffusion of mobile devices has motivated research towards optimizing energy consumption of software systems - including apps - targeting such devices. Besides efforts aimed at dealing with various kinds of energy bugs, the adoption of Organic Light-Emitting Diode (OLED) screens has motivated research towards reducing energy consumption by choosing an appropriate color palette. Whilst past research in this area aimed at optimizing energy while keeping an acceptable level of contrast, this paper proposes an approach, named GEMMA (Gui Energy Multi-objective optiMization for Android apps), for generating color palettes using a multi-objective optimization technique, which produces color solutions optimizing energy consumption and contrast while using consistent colors with respect to the original color palette. An empirical evaluation that we performed on 25 Android apps demonstrates not only significant improvements in terms of the three different objectives, but also confirmed that in most cases users still perceived the choices of colors as attractive. Finally, for several apps we interviewed the original developers, who in some cases expressed the intent to adopt the proposed choice of color palette, whereas in other cases pointed out directions for future improvements.</p>
                                                        
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ASE</span>
                                                    <span>2013</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Detecting Bad Smells in Source Code Using Change History Information
                                                    <br>by <em>F. Palomba, G. Bavota, M. Di Penta, R. Oliveto, A. De Lucia, D. Poshyvanyk</em>
                                                    <h5>28th IEEE/ACM International Conference on Automated Software Engineering</h5></h4>
                                                    <p>Code smells represent symptoms of poor implementation choices. Previous studies found that these smells make source code more difficult to maintain, possibly also increasing its fault-proneness. There are several approaches that identify smells based on code analysis techniques. However, we observe that many code smells are intrinsically characterized by how code elements change over time. Thus, relying solely on structural information may not be sufficient to detect all the smells accurately. We propose an approach to detect five different code smells, namely Divergent Change, Shotgun Surgery, Parallel Inheritance, Blob, and Feature Envy, by exploiting change history information mined from versioning systems. We applied approach, coined as HIST (Historical Information for Smell deTection), to eight software projects written in Java, and wherever possible compared with existing state-of-the-art smell detectors based on source code analysis. The results indicate that HIST's precision ranges between 61% and 80%, and its recall ranges between 61% and 100%. More importantly, the results confirm that HIST is able to identify code smells that cannot be identified through approaches solely based on code analysis.</p>
                                                        
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="section color-2">
                            <div class="section-container">
                                <div class="row">
                                    <div class="col-md-10 col-md-offset-1">
                                        <div class="title text-center">
                                            <h3>Best Paper Awards</h3>
                                        </div>
                                        <ul class="ul-dates-gray">
                                            <li>
                                                <div class="dates">
                                                    <span style="font-size: 11px;">HEALTHINF</span>
                                                    <span>2020</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Combining Rhythmic and Morphological ECG Features for Automatic Detection of Atrial Fibrillation<br>
                                                        by <em>G. Laudato, F. Boldi, A. Colavita, G. Rosa, S. Scalabrino, P. Torchitti, A. Lazich, R. Oliveto</em>
                                                        <h5>13th International Conference on Health Informatics</h5></h4>
                                                    <p>Atrial fibrillation (AF) is the most common type of heart arrhythmia. AF is highly associated with other cardiovascular diseases, such as heart failure, coronary artery disease and can lead to stroke. Unfortunately, in some cases people with atrial fibrillation have no explicit symptoms and are unaware of their condition until it is discovered during a physical examination. Thus, it is considered a priority to define highly accurate automatic approaches to detect such a pathology in the context of a massive screening. For this reason, in the recent years several approaches have been defined to automatically detect AF. These approaches are often based on machine learning techniques and—most of them—analyse the heart rhythm to make a prediction. Even if AF can be diagnosed by analysing the rhythm, the analysis of the morphology of a heart beat is also important. Indeed, during an AF events the P wave could be absent and fibrillation waves may appear in its place. This means that the presence of only arrhythmia could be not enough to detect an AF events. Based on the above consideration we have presented MORPHYTHM, an approach that use machine learning to combine rhythm and morphological features to identify AF events. The results we achieved in an empirical evaluation seems promising. In this paper we present an extension of MORPHYTHM, called LOCAL MORPHYTHM, aiming at further improving the detection accuracy of AF events. An empirical evaluation of LOCAL MORPHYTHM has shown significantly better results in the classification process with respect to MORPHYTHM, particularly for what concerns the true positives and false negatives.</p>

                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>SCAM</span>
                                                    <span>2012</span>
                                                </div>
                                                <div class="content">
                                                    <h4>When does a Refactoring Induce Bugs? An Empirical Study<br>
                                                    by <em>G. Bavota, B. De Carluccio, A. De Lucia, M. Di Penta, R. Oliveto, O. Strollo</em>
                                                    <h5>12th IEEE International Working Conference on Source Code Analysis and Manipulation</h5></h4>
                                                    <p>Refactorings are - as defined by Fowler - behavior preserving source code transformations. Their main purpose is to improve maintainability or comprehensibility, or also reduce the code footprint if needed. In principle, refactorings are defined as simple operations so that are "unlikely to go wrong" and introduce faults. In practice, refactoring activities could have their risks, as other changes. This paper reports an empirical study carried out on three Java software systems, namely Apache Ant, Xerces, and Ar-go UML, aimed at investigating to what extent refactoring activities induce faults. Specifically, we automatically detect (and then manually validate) 15,008 refactoring operations (of 52 different kinds) using an existing tool (Ref-Finder). Then, we use the SZZ algorithm to determine whether it is likely that refactorings induced a fault. Results indicate that, while some kinds of refactorings are unlikely to be harmful, others, such as refactorings involving hierarchies (e.g., pull up method), tend to induce faults very frequently. This suggests more accurate code inspection or testing activities when such specific refactorings are performed.</p>
                                                        
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ICPC</span>
                                                    <span>2011</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Improving IR-based Traceability Recovery Using Smoothing Filters<br>
                                                    by <em>A. De Lucia, M. Di Penta, R. Oliveto, A. Panichella, S. Panichella</em>
                                                    <h5>19th International Conference on Program Comprehension</h5></h4>
                                                    <p>Information Retrieval methods have been largely adopted to identify traceability links based on the textual similarity of software artifacts. However, noise due to word usage in software artifacts might negatively affect the recovery accuracy. We propose the use of smoothing filters to reduce the effect of noise in software artifacts and improve the performances of traceability recovery methods. An empirical evaluation performed on two repositories indicates that the usage of a smoothing filter is able to significantly improve the performances of Vector Space Model and Latent Semantic Indexing. Such a result suggests that other than being used for traceability recovery the proposed filter can be used to improve performances of various other software engineering approaches based on textual analysis.</p>
                                                        
                                                </div>
                                            </li>
                                            <li>
                                                <div class="dates">
                                                    <span>ICSM<br>ERA</span>
                                                    <span>2010</span>
                                                </div>
                                                <div class="content">
                                                    <h4>Physical and Conceptual Identifier Dispersion: Measures and Relation to Fault Proneness<br>
                                                    by <em>V. Arnaoudova, L. Eshkevari, R. Oliveto, Y.-G. Gu&eacute;h&eacute;neuc, G. Antoniol</em>
                                                    <h5>26th IEEE International Conference on Software Maintenance - ERA Track</h5></h4>
                                                    <p>Poorly-chosen identifiers have been reported in the literature as misleading and increasing the program comprehension effort. Identifiers are composed of terms, which can be dictionary words, acronyms, contractions, or simple strings. We conjecture that the use of identical terms in different contexts may increase the risk of faults. We investigate our conjecture using a measure combining term entropy and term context coverage to study whether certain terms increase the odds ratios of methods to be fault-prone. Entropy measures the physical dispersion of terms in a program: the higher the entropy, the more scattered across the program the terms. Context coverage measures the conceptual dispersion of terms: the higher their context coverage, the more unrelated the methods using them. We compute term entropy and context coverage of terms extracted from identifiers in Rhino 1.4R3 and ArgoUML 0.16. We show statistically that methods containing terms with high entropy and context coverage are more fault-prone than others.</p>
                                                        
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                                    
                            </div>
                        </div>
                        <!-- Start of StatCounter Code for Default Guide -->
                        <script type="text/javascript">
                        var sc_project=10374779; 
                        var sc_invisible=1; 
                        var sc_security="5bad876a"; 
                        var scJsHost = (("https:" == document.location.protocol) ?
                        "https://secure." : "http://www.");
                        document.write("<sc"+"ript type='text/javascript' src='" +
                        scJsHost+
                        "statcounter.com/counter/counter.js'></"+"script>");
                        </script>
                        <noscript><div class="statcounter"><a title="shopify
                        analytics ecommerce tracking"
                        href="http://statcounter.com/shopify/" target="_blank"><img
                        class="statcounter"
                        src="http://c.statcounter.com/10374779/0/5bad876a/0/"
                        alt="shopify analytics ecommerce
                        tracking"></a></div></noscript>
                        <!-- End of StatCounter Code for Default Guide -->
                    </div>
                </div>
                
            </div>
        </div>
    </body>
</html>

